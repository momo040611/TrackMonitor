# TrackMonitor

一个一体化的前端埋点监控平台 包含埋点sdk，后端server，以及可视化平台

## track-sdk 模块完成情况说明

本 SDK 目前划分为三个核心插件模块：行为埋点、性能监控、错误监控。整体架构已经成型，但不同模块的完成度不一样，当前状态如下。

---

### 一、行为插件（Behavior Plugin）

**定位：** 采集前端常规行为数据，例如页面曝光、按钮点击、作品相关操作等，并通过统一的 Tracker 管线上报。

**已经完成的能力：**

- **插件与核心的集成**
  - 通过统一的工厂函数对外暴露。
  - 实现了标准插件生命周期：`setup` 和 `cleanup`。
  - 在初始化阶段接收核心 `CoreContext`，同步全局上下文，完成各类事件采集器的初始化。
  - 在销毁阶段统一执行内部收集到的清理函数，移除事件监听，避免内存泄漏和重复绑定。

- **Tracker 实例注入**
  - 插件初始化时支持注入全局 `tracker` 实例。
  - 内部通过工具方法将 `tracker` 挂载到行为采集逻辑中，方便随时上报自定义行为事件。

- **多种行为采集能力**
  - 页面浏览埋点：支持页面访问、路由切换等场景的曝光上报。
  - 点击行为埋点：包括通用按钮点击、「生成相关」点击、「作品相关」点击等。
  - 曝光埋点：支持元素曝光/作品展示等场景的上报。
  - 各类采集逻辑均通过独立的 handler 组织，插件负责统一初始化和销毁。

- **功能开关与配置**
  - 支持开关自动埋点整体能力。
  - 支持按类别开关：页面浏览、点击、曝光等。
  - 方便在不同业务场景按需裁剪埋点范围。

**当前评估：** 行为插件整体可用、可上线：初始化和销毁生命周期完整，主要采集场景已经覆盖，对 Tracker 的依赖明确，可以与核心埋点管线稳定协作。

---

### 二、性能插件（Performance Plugin）

**定位：** 采集前端页面性能数据（页面加载、资源加载、网络请求等），进行标准化处理后通过核心管线上报。

**已经完成的能力：**

- **性能数据模型与配置体系**
  - 定义了较完整的性能枚举和数据结构：包括页面加载、资源、网络、交互、长任务、内存、自定义等多种指标类型。
  - 提供了较丰富的插件配置项：是否开启各类性能监控、采样率、资源采样率、上报间隔、缓存大小、忽略指标列表、自定义过滤规则等。
  - 提供默认配置，方便开箱即用。

- **性能监控核心类**
  - 封装性能监控的启动和停止逻辑：负责创建和管理各类性能处理器，根据配置初始化页面加载、资源加载等监控。
  - 提供统一的数据处理入口：对采集到的性能原始数据进行采样过滤、忽略规则过滤、自定义规则过滤；将原始数据封装为统一的性能信息对象（包含指标类型、名称、数值、单位、时间戳、页面信息、UserAgent 以及详细指标字段）。

- **事件分发机制**
  - 支持注册多个性能数据处理回调：处理后的标准性能数据会依次分发给所有已注册的处理器；单个处理器内部错误不会影响整体流程，具备一定容错能力。
  - 预留与核心管线的对接能力：可以通过统一的发送能力，将性能数据上报为埋点事件。

**尚未完成 / 存在的问题：**

- 实现存在两套版本，尚未统一：目录下既有基于类的性能插件实现，也有基于工厂函数的另一套实现，二者在类型和接口上存在重复与不一致，需要后续收敛为一套清晰的插件实现。
- 关键处理器未完全实现：页面加载性能处理器的工厂函数目前仍是占位实现，默认会抛出未实现错误，在默认开启页面加载监控的配置下，性能插件整体无法稳定运行。
- 生命周期清理逻辑不完整：监控核心类内部已经设计了停止/销毁方法和清理函数容器，但和插件 `cleanup` 生命周期的对接尚未完成，缺少统一的销毁入口来解除性能观察和事件监听。
- 浏览器环境兼容性有待完善：在构建性能信息时直接访问浏览器全局对象，在 SSR 或非浏览器环境下使用时需要补充环境检测和降级逻辑，避免运行时错误。

**当前评估：** 性能模块目前处于设计较完整、实现半完成的阶段：数据模型和配置体系相对健全，监控与分发框架已经搭好，但因为存在未实现的关键处理器、两套实现未统一、清理逻辑未打通，不建议直接在生产环境启用，适合作为后续迭代的基础框架。

---

### 三、错误插件（Error Plugin）

**定位：** 统一捕获前端运行时错误、Promise 未处理异常、资源加载错误、HTTP 请求错误，以及手动上报的业务错误，标准化后通过核心管线上报。

**已经完成的能力：**

- **完整的错误类型与配置**
  - 错误类型覆盖：JavaScript 运行时错误、Promise 未处理异常、资源加载错误、HTTP 请求错误、手动上报错误。
  - 支持丰富的配置项：是否开启各类错误类型的采集、错误采样率、最大错误上报数量、忽略错误列表、自定义错误过滤规则等。

- **统一的错误标准化流程**
  - 内部定义统一的错误信息结构：包含错误类型、错误信息、堆栈、发生时间、页面信息、UserAgent 以及详细扩展信息。
  - 通过统一入口对不同来源的错误（原生错误对象、浏览器错误事件、Promise 拒绝事件、资源/HTTP 错误等）进行标准化处理，生成统一格式的错误对象。

- **多种错误来源的自动捕获**
  - 通过全局监听实现自动采集：包括 JavaScript 运行时错误、未捕获的 Promise 异常、资源加载错误，以及可选的 HTTP 请求错误。
  - 每类监听在安装和移除时都有对应的清理函数管理。

- **埋点上报与生命周期管理**
  - 插件在初始化时，从核心上下文中获取 Tracker 实例引用，所有处理完成的错误会统一通过 Tracker 上报为错误事件。
  - 插件实现了完整的生命周期：在 setup 阶段安装所有开启的错误监听器，在 cleanup 阶段移除所有已安装的监听器，释放资源。
  - 额外提供高级能力：暂停/恢复错误监控、查询和重置错误计数、运行时更新配置等。

**尚待完善的点：**

- 环境兼容性：在构造错误信息时，会访问页面 URL、标题、UserAgent 等浏览器相关信息。自动错误采集路径已经对非浏览器环境做了初步保护，但手动上报等路径仍需补充环境判断，防止在 SSR / Node 环境下抛出异常。
- 对外 API 一致性：模块内部的插件实例提供了完整的错误上报接口，对外同时还暴露了一个简单的手动捕获函数，目前仅做日志输出，尚未完全整合进统一错误处理管线，需要后续统一对外 API，让所有错误上报都走同一套标准化与上报流程。

**当前评估：** 错误插件整体功能相对完善且可用：已覆盖主流前端错误场景，提供了完整的错误过滤、采样和计数控制，生命周期和清理机制健全。只需在环境兼容和顶层 API 一致性方面做进一步打磨，即可满足较严格的生产使用要求。
